<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="utf-8" charset="utf-8" http-equiv="encoding">

    <script src="js/three.js"></script>
    <script src="js/PLYLoader.js"></script>

    <style>
      body,html{ background-color: black; background-image: url('Images/DragonFly.png'); background-position: 50% 50%; background-repeat: no-repeat; width: 100%; height: 100%; padding: 0; margin: 0; overflow: hidden; }
      div { width: 99%; border: 1px solid navy; -webkit-border-radius: 2px; border-radius: 2px; padding: 4px; margin: 1px; }
      canvas { display: block; position: absolute; margin: 0; width: 100%; height: 100%; }

      .fixed-menu {
        position: fixed;
        z-index: 1;
        display: inline-block;
        background-color: whitesmoke;
        top: 0px;
        margin: 0px;
        padding: 1px;
        width: 100%;
      }
    </style>

    <!-- Original OBJ source code: https://codepen.io/Mamboleoo/pen/PqjGdN -->
    <!-- PLY Examples from: https://github.com/mrdoob/three.js -->
    <!-- More PLY examples: https://people.sc.fsu.edu/~jburkardt/data/data.html -->
    <title>PLY Viewer</title>
  </head>
  <body onload="reset_all()">
    <div class="fixed-menu">
      <div>
        <label for="file" style="color: navy;">PLY File: &nbsp;</label>
        <input type="file" id="file_input" name="file" onchange="init()" />
        <button type="reset" id="reset" onclick="reset_only()" style="float: right; width: 55px; margin-right: 5px; margin-left: 5px;">Reset</button>
        <label for="wireframe" style="float: right; margin-right: 5px;">Wireframe</label>
        <input type="checkbox" id="wireframe" name="wireframe" onchange="show_wireframe()" style="float: right; margin-right: 5px;" />
        <input type="number" id="ply_scale" name="ply_scale" onchange="set_ply_scale()" min="0.5" max="1.5" value="1" step="0.5" style="float: right; margin-right: 5px; width: 45px;" />
        <label for="ply_scale" style="float: right; margin-right: 5px;">Scale:</label>
      </div>
      <div>
        <input type="radio" id="light" name="mode" value="Light" onchange="radio_changed()" />
        <label for="other">Light</label>
        <input type="radio" id="rotate" name="mode" value="Rotate" onchange="radio_changed()" checked />
        <label for="other">Rotate &nbsp;</label>
        <label for="number" style="color: blue;">X</label>
        <input type="number" id="rotation_x" onchange="rot_x_changed()" min="-0.05" max="0.05" value="0" step="0.001" style="width: 60px;" />&nbsp;
        <label for="number" style="color: blue;">Y</label>
        <input type="number" id="rotation_y" onchange="rot_y_changed()" min="-0.05" max="0.05" value="0" step="0.001" style="width: 60px;" />&nbsp;
        <label for="number" style="color: blue;">Z</label>
        <input type="number" id="rotation_z" onchange="rot_z_changed()" min="-0.05" max="0.05" value="0" step="0.001" style="width: 60px;" />&nbsp; &nbsp;
        <label for="number">Position : </label>
        <label for="number" style="color: green;">X</label>
        <input type="number" id="position_x" onchange="pos_x_changed()" min="-1000" max="1000" value="0" step="1" style="width: 55px;" />&nbsp;
        <label for="number" style="color: green;">Y</label>
        <input type="number" id="position_y" onchange="pos_y_changed()" min="-1000" max="1000" value="0" step="1" style="width: 55px;" />&nbsp;
        <label for="number" style="color: green;">Z</label>
        <input type="number" id="position_z" onchange="pos_z_changed()" min="-2000" max="2000" value="0" step="1" style="width: 55px;" />
        <input type="color" id="back_color" name="back_color" onchange="set_back_color()" style="float: right; background: none; padding: 0; width: 30px; margin-right: 5px;" />
        <label for="back_color" style="float: right; margin-top: 3px; margin-right: 5px;">BG</label>
        <input type="color" id="ambient_light_color" name="ambient_light_color" onchange="set_ambient_light_color()" style="float: right; background: none; padding: 0; width: 30px; margin-right: 5px;" />
        <label for="ambient_light_color" style="float: right; margin-top: 3px; margin-right: 5px;">AL</label>
        <input type="number" id="directional_light_intensity" name="directional_light_intensity" min="0.05" max="1" step="0.05" value="0.8" onchange="set_directional_light_intensity()" style="float: right; width: 50px; margin-right: 5px;" />
        <label for="directional_light_intensity" style="float: right; margin-top: 3px; margin-right: 5px;">DL</label>
      </div>
    </div><br />

    <canvas id="scene">
      Your browser does not support HTML5 canvas tag
    </canvas>

    <script>
      function initialize_event_listeners() {
        var cnvs = document.getElementById('scene');

        cnvs.addEventListener( 'wheel', (event) => {
          var pz = document.getElementById('position_z');
          var val = parseInt(pz.value) + parseInt(event.deltaY * 0.01745)
          pz.value = val;
          pz.onchange();
        }, false);

        cnvs.addEventListener( 'mousedown', (event) => {
          if (event.button == 0) {
            mouse_rotation = true;
          }
        }, false);

        cnvs.addEventListener( 'mouseup', (event) => {
          if (event.button == 0) {
            mouse_rotation = false;
          }
        }, false);

        cnvs.addEventListener( 'mousemove', (event) => {
          if (mouse_rotation) {
            event.preventDefault();
            let x = Math.abs(mesh.rotation.x);

            if (x > 2 * Math.PI ) { mesh.rotation.x = 0; }

            mesh.rotation.x += event.clientX * event.movementY * 0.0000087;

            if (x > 1.57 && x < 4.71) {
              mesh.rotation.y -= event.clientY * event.movementX * 0.00001745;
            } else {
              mesh.rotation.y += event.clientY * event.movementX * 0.00001745;
            }
          }
        }, false);
      }
    </script>

    <script>
      var renderer, scene, camera, ambientLight, directionalLight, mesh;
      var ww = window.innerWidth,	wh = window.innerHeight;
      var mouse_rotation = false, reset_rotation = false, events_initialized = false;
      var rot_x = 0, rot_y = 0, rot_z = 0, pos_x = 0, pos_y = 0, pos_z = 0;
      previous_ply_scale = 1;
      var selected_ply_file = null;

      // Manager from ThreeJs to track a loader and its status
      var manager = new THREE.LoadingManager();
      // Loader for selected file from Three.js
      const ply_loader = new THREE.PLYLoader( manager );

      function set_back_color() { document.body.style.backgroundColor = document.getElementById('back_color').value; }

      function set_ambient_light_color() {
        let colors = document.getElementById('ambient_light_color').value; // hex format '#rrggbb'
        ambientLight.color = {
          'r': parseInt(colors.substring(1, 3), 16),
          'g': parseInt(colors.substring(3, 5), 16),
          'b': parseInt(colors.substring(5), 16)
        };
      }

      function set_directional_light_intensity() {
        directionalLight.intensity = parseFloat( document.getElementById('directional_light_intensity').value );
      }

      function set_ply_scale() {
        if (previous_ply_scale == 0.5) {
          mesh.scale.multiplyScalar( 2 );
        } else if (previous_ply_scale == 1.5) {
          mesh.scale.multiplyScalar( 2/3 );
        } else {
          mesh.scale.multiplyScalar( parseFloat(document.getElementById('ply_scale').value) );
        }

        previous_ply_scale = parseFloat(document.getElementById('ply_scale').value);
      }

      function radio_changed() {
        if (document.getElementById('light').checked) {
          document.getElementById('rotation_x').value = directionalLight.position.x;
          document.getElementById('rotation_y').value = directionalLight.position.y;
          document.getElementById('rotation_z').value = directionalLight.position.z;
          document.getElementById('rotation_x').min = document.getElementById('rotation_y').min = document.getElementById('rotation_z').min = -500;
          document.getElementById('rotation_x').max = document.getElementById('rotation_y').max = document.getElementById('rotation_z').max = 500;
          document.getElementById('rotation_x').step = document.getElementById('rotation_y').step = document.getElementById('rotation_z').step = 10;
        } else {
          document.getElementById('rotation_x').value = rot_x;
          document.getElementById('rotation_y').value = rot_y;
          document.getElementById('rotation_z').value = rot_z;
          document.getElementById('rotation_x').min = document.getElementById('rotation_y').min = document.getElementById('rotation_z').min = -0.05;
          document.getElementById('rotation_x').max = document.getElementById('rotation_y').max = document.getElementById('rotation_z').max = 0.05;
          document.getElementById('rotation_x').step = document.getElementById('rotation_y').step = document.getElementById('rotation_z').step = 0.001;
        }
      }

      function rot_x_changed() {
        let x = parseFloat(document.getElementById('rotation_x').value);
        let y = parseFloat(document.getElementById('rotation_y').value);
        let z = parseFloat(document.getElementById('rotation_z').value);

        if (document.getElementById('light').checked) {
          directionalLight.position.set( x, y, z );
        } else {
          rot_x = x;
        }
      }

      function rot_y_changed() {
        let x = parseFloat(document.getElementById('rotation_x').value);
        let y = parseFloat(document.getElementById('rotation_y').value);
        let z = parseFloat(document.getElementById('rotation_z').value);

        if (document.getElementById('light').checked) {
          directionalLight.position.set( x, y, z );
        } else {
          rot_y = y;
        }
      }

      function rot_z_changed() {
        let x = parseFloat(document.getElementById('rotation_x').value);
        let y = parseFloat(document.getElementById('rotation_y').value);
        let z = parseFloat(document.getElementById('rotation_z').value);

        if (document.getElementById('light').checked) {
          directionalLight.position.set( x, y, z );
        } else {
          rot_z = z;
        }
      }

      function pos_x_changed() { pos_x = parseInt(document.getElementById('position_x').value); }
      function pos_y_changed() { pos_y = parseInt(document.getElementById('position_y').value); }
      function pos_z_changed() { pos_z = parseInt(document.getElementById('position_z').value); }

      function init(){
        // Loaded file(s)
        var fi = document.getElementById('file_input');
        selected_ply_file = fi.files[0];

        if (scene != null) {
          // Reset the ply scale values
          document.getElementById('ply_scale').value = 1;
          set_ply_scale()

          // Reset all values
          reset_all( false, true );

          scene.remove.apply(scene, scene.children);
        }

        enable_disable( true );

        if (!fi.files[0].name.endsWith('.ply')) {
          return;
        } else {
          selected_ply_file = fi.files[0];
        }

        document.body.style.backgroundImage = "none";
        enable_disable( false );

        renderer = new THREE.WebGLRenderer({ canvas : document.getElementById('scene'), antialias: true, alpha: true });
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(ww, wh);
        renderer.setClearColor( 0xFFFFFF, 0); // Allow setting the background color

        // The following can be used instead of the canvas but the window mouse
        // events might be tricky to set due to the presence of the fixed menu
        //document.body.appendChild( renderer.domElement );

        scene = new THREE.Scene();

        if (!events_initialized) {initialize_event_listeners(); events_initialized = true; }

        // Add ambient light to the scene
        ambientLight = new THREE.AmbientLight(0x000000);
        scene.add(ambientLight);

        // The following provides a sort of "liquid background" that object can go through
        //var material = new THREE.MeshStandardMaterial({ color: 0x0077FF, side: THREE.DoubleSide }); //shades of blue
        //mesh = new THREE.Mesh(new THREE.PlaneGeometry( ww, wh ), material);
        //scene.add(mesh);

        camera = new THREE.PerspectiveCamera( 45, ww/wh, 0.1, 2000 );
        camera.position.set( 0, 0, 250 );
        scene.add(camera);

        // Add directional light to the scene
        directionalLight = new THREE.DirectionalLight( 0xFFFFFF, 0.8 );
        directionalLight.position.set( 0, 0, 250 );
        directionalLight.lookAt(new THREE.Vector3( 0, 0, 0 ));
        scene.add( directionalLight );

        // Load the ply file
        loadFile();
      }

      var loadFile = function(){
        // Launch loading of the selected file, addFileInScene is the callback when it's ready
        ply_loader.load( URL.createObjectURL(selected_ply_file), addFileInScene );
      };

      var addFileInScene = function(object){
        var smooth = object.clone();
        smooth.computeVertexNormals();
        smooth.mergeVertices();

        //var material = new THREE.MeshStandardMaterial({ color: 0x0077FF }); //shades of blue
        var material = new THREE.MeshPhongMaterial( {
          polygonOffset: true,
          polygonOffsetFactor: 1,
          polygonOffsetUnits: 1,
          color: 0xFFFFFF,
          specular: 0x111111,
          shininess: 100,
          vertexColors: THREE.VertexColors
        });

        material.flatShading = false;

        mesh = new THREE.Mesh(smooth, material);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.scale.multiplyScalar( parseFloat(document.getElementById('ply_scale').value ));

        // Add mesh to the scene
        scene.add(mesh)

        camera.lookAt( mesh.position );

        render();
      };

      var show_wireframe = function () {
        // Go through all children of the loaded object and search for a Mesh
        mesh.traverse( function ( child ) {
          // This allow us to check if the children is an instance of the Mesh constructor
    	    if(child instanceof THREE.Mesh){
            if (document.getElementById('wireframe').checked) {
              child.material.wireframe = true;
            } else {
              child.material.wireframe = false;
            }
    		  }
    	  });
      }

      var render = function () {
        requestAnimationFrame( render );

        // Move the mesh in the scene
        mesh.position.x = pos_x;
        mesh.position.y = pos_y;
        mesh.position.z = pos_z;

        // Reset mesh rotational values
        if (reset_rotation) {
          mesh.rotation.x = 0;
          mesh.rotation.y = 0;
          mesh.rotation.z = 0;
          reset_rotation = false;
        }

        // Rotate the mesh
        if (!mouse_rotation) {
          mesh.rotation.x += rot_x;
          mesh.rotation.y += rot_y;
          mesh.rotation.z += rot_z;
        }

      	renderer.render( scene, camera );
      };

      var reset_only = function () {
        reset_all( false, true );
      }

      var reset_all = function( values = false, reset = false ) {
        // Reset all current positional and rotational values
        rot_x = document.getElementById('rotation_x').value = 0;
        rot_y = document.getElementById('rotation_y').value = 0;
        rot_z = document.getElementById('rotation_z').value = 0;
        pos_x = document.getElementById('position_x').value = 0;
        pos_y = document.getElementById('position_y').value = 0;
        pos_z = document.getElementById('position_z').value = 0;
        document.getElementById('ambient_light_color').value = "0x000000";
        document.getElementById('directional_light_intensity').value = 0.8;

        // Reset the radio inputs
        document.getElementById('rotate').checked = true;
        document.getElementById('light').checked = false;
        radio_changed();

        // Reset the ply scale values
        document.getElementById('ply_scale').value = 1;

        // Reset the wireframe checkbox
        document.getElementById('wireframe').checked = false;

        reset_rotation = true;

        // Reset the view
        if (!values && reset) {
          directionalLight.position.set( 0, 0, 250 );
          set_ply_scale()
          show_wireframe();
          set_ambient_light_color();
          set_directional_light_intensity();
        }

        if (!values && !reset) {
          // Page (re)loading so reset the file input and back color and disable controls
          document.getElementById('file_input').value = "";
          document.getElementById('back_color').value = "0x000000";
          enable_disable( true );
        }
      };

      var enable_disable = function( disable = false ) {
        document.getElementById('light').disabled = disable;
        document.getElementById('rotate').disabled = disable;
        document.getElementById('rotation_x').disabled = disable;
        document.getElementById('rotation_y').disabled = disable;
        document.getElementById('rotation_z').disabled = disable;
        document.getElementById('position_x').disabled = disable;
        document.getElementById('position_y').disabled = disable;
        document.getElementById('position_z').disabled = disable;
        document.getElementById('wireframe').disabled = disable;
        document.getElementById('ply_scale').disabled = disable;
        document.getElementById('ambient_light_color').disabled = disable;
        document.getElementById('directional_light_intensity').disabled = disable;
        document.getElementById('back_color').disabled = disable;
        document.getElementById('reset').disabled = disable;
      }
    </script>
  </body>
</html>